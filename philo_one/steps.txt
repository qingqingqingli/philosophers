# learning

- each thread points to a separate philosopher struct with the relevant information

# program steps

* process input [DONE]

* validate input [DONE & DOUBLE CHECK AT THE END]

* create philosopher threads
    - malloc `number_of_philosopher` threads [DONE]
    - create threads and pass on the function to run [DONE]
    - [question - solved] how to pass data struct to the function so it can use data (index of each philosopher, time required for each action) -> pass in as an argument [DONE]

* start action

[eat]
    - Each fork is a mutex. When any fork left or right is available, grab it --> PRINT "timestamp_in_ms X has taken a fork"
    - check if the current timestamp to the last time eat timestamp is bigger then `time_to_die`. If so, terminate this thread and all other threads. Otherwise, keep waiting. [LATER]
    - When the philosopher has two forks --> PRINT "timestamp_in_ms X is eating"
    - sleep for the required `time_to_eat`
[sleep]
    - drop 2 forks, unlock these forks' mutex and starts sleeping --> PRINT "timestamp_in_ms X is sleeping"
    - sleep for the required `time_to_sleep`
[think]
    - PRINT "timestamp_in_ms X is thinking" after finish sleeping
    - Whenever two forks become available, the philosopher starts eating

* check if program ends
    - `number_of_times_each_philosopher_must_eat` reached
    - a philosopher dies
        - does not start eating at the beginning of the stimulation
        - does not start eating within `time_to_eat` milliseconds after starting last meal
        - [question] how does it signal other philosophers and terminate all threads?